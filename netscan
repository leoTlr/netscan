#!/usr/bin/python

import argparse
import threading
import time
import logging
from sys import exit

# for input validation before main
from ressources.helper_funcs import check_privileges, is_valid_cidr, is_valid_dd_netmask, is_valid_portnr

# needed in main
from ressources.helper_funcs import calc_addr_range, save_xml, compare_xml, prepare_path
from ressources.thread_classes import listenerThread, udpSenderThread

# ------ commandline parsing setup -------------------
# TODO: -s and -c in mutually exclusive grp
#       -s and -sf in mutually excl grp
#       input validation for -c

desc = """
Host discovery tool.
Will list and count all responding devices in given network by sending an
UDP-packet to a closed port at each address in network and waiting for
ICMP: Port unreachable responses.
"""

parser = argparse.ArgumentParser(description=desc)

parser.add_argument('ip_address', metavar='IPv4-address', help='IPv4 Address in CIDR-notation')
parser.add_argument('-nm', '--netmask', help='netmask in dotted decimal notation \
                    (only needed if ip_address not in CIDR-notation)', metavar='NM')
parser.add_argument('-w', '--wait', help='define time (seconds) to wait for responses \
                     after all packets are sent. Default 2', type=int, metavar='SEC')
parser.add_argument('-p', '--port', help='define a closed UDP port to use. Default 65333',
                    type=int)
parser.add_argument('-q', '--quiet', action='store_true',
                    help='only output number of discovered hosts (or number of changes since\
                     save if -c is selected)')
parser.add_argument('-s', '--save', action='store_true', help='save discovered hosts \
                        as .xml file in ./saved_scans')
parser.add_argument('-sf', '--save-file', metavar='PATH', help='like -s but save to provided \
                        directory or file')
parser.add_argument('-c', '--compare', metavar='PATH', help='scan and compare with \
                    saved hosts in file. If this is selected with -q, the number of\
                     changes is returned')
args = parser.parse_args()
# ------ end of commandline parsing setup --------------

# ------ setup logging -------------------------------
class infoWithoutLevelPrefixFormatter(logging.Formatter):
    """ different log formatting for loglevel INFO """
    def format(self, record):
        if record.levelno != logging.INFO:
            record.msg = '[{}] {}'.format(record.levelname, record.msg)
        return super().format(record)

# create a custom handler, set its formatter to the custom formatter
handler = logging.StreamHandler()
handler.setFormatter(infoWithoutLevelPrefixFormatter())

# adapt loglevel to user input
if args.quiet:
    log_level = logging.ERROR
else:
    log_level = logging.INFO

# configure the logger to use the custom handler (arg as list because it needs to be an iterable)
logging.basicConfig(level=log_level, handlers=[handler])
# ------ end logging setup ---------------------------

def main(address, dd_netmask=None):

    # calculate first and last address of given IPv4-network
    if not dd_netmask: # cidr-notation
        network_addr, broadcast_addr, subnet = calc_addr_range(address)
    else: # non-cidr-notation
        network_addr, broadcast_addr, subnet = calc_addr_range(address, dd_netmask)

    
    # create listener thread
    listener_thread = listenerThread()
    if args.quiet:
        listener_thread.quiet = True
    if args.save or args.save_file or args.compare:
        listener_thread.prepare_xml_data = True

    listener_thread.start()

    # create sender thread
    sender_thread = udpSenderThread(network_addr, broadcast_addr)
    if args.port:
        sender_thread.closed_port = args.port
    if args.quiet:
        sender_thread.quiet = True

    sender_thread.start()
    sender_thread.join(timeout=5) # wait for sender thread to complete

    # wait for late responses
    if args.wait: time.sleep(args.wait)
    else: time.sleep(2)

    listener_thread.stop(abnormal=False)
    listener_thread.join(timeout=5) # wait for listener to finish

    netw_addr_str = sender_thread.bin2DottedDecimal(network_addr)
    cidr_nw_str = '{}/{}'.format(netw_addr_str, subnet)

    # in case output shall be saved, collect data and write to file
    if args.save or args.save_file or args.compare:
        data_set = listener_thread.xml_set
        if args.save:
            save_xml(data_set, cidr_nw_str)
        elif args.save_file:
            save_xml(data_set, cidr_nw_str, path=args.save_file)

    if not listener_thread.stoppedAbnormally() or not sender_thread.stoppedAbnormally():
        if args.compare:
            msg_str = str(compare_xml(data_set, cidr_nw_str, args.compare))
            logging.info(msg_str)
            exit(0)
        else:
            logging.info('{} hosts up in {}'.format(listener_thread.hostup_counter, cidr_nw_str))
            if args.quiet:
                # might seem contra intuitive but remember args.quiet -> loglevel = ERROR -> info wouldnt get printed
                print(listener_thread.hostup_counter)
            exit(0)
    else:
        logging.error('scan failed')
        exit(-1)


if __name__ == '__main__':
    # verify commandline args and run main

    if args.port:
        if is_valid_portnr(args.port):
            pass
        else:
            logging.error('illegal port')
            exit(-1)

    if check_privileges():
        pass
    else:
        logging.error('could not create socket. exiting')
        exit(-1)

    if is_valid_cidr(args.ip_address):
        main(args.ip_address)
    elif is_valid_dd_netmask(args.ip_address, args.netmask):
        main(args.ip_address, args.netmask)
        
