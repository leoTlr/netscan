#!/usr/bin/python
#%%

import argparse
import threading
import socket # test for root
from itertools import product # calc_addr_range()

from ressources.protocol_structs import IP, ICMP
from ressources.thread_classes import listenerThread, udpSenderThread

from traceback import format_exc # debug
import time # debug

parser = argparse.ArgumentParser()
parser.add_argument('network_address', help='IPv4 Address in CIDR-notation')
args = parser.parse_args()


def main(cidr_type_address):
    # separates address to network part and all possible hostparts in subnet
    netw_part, subnet, hostparts_tuple_list = calc_addr_range(cidr_type_address)

    # remove network and broadcast addresses
    # /31 produces an empty list, sice there are no host-addresses
    # /32 produces a list containing only the input address for single IP checks
    hostparts_tuple_list = hostparts_tuple_list[1:-1]

    # create listener thread
    listener_thread = listenerThread()
    listener_thread.start()

    # create sender thread
    sender_thread = udpSenderThread(netw_part, hostparts_tuple_list)
    sender_thread.start()

    # start sending as soon as listener thread is ready
    if listener_thread.is_listening:
        sender_thread.waitLock.release()

    # wait for sender thread to complete
    sender_thread.join()
    time.sleep(2) # wait for responses
    listener_thread.stop()
    listener_thread.join() # wait for listener to finish

    netw_addr = netw_part+'0'*(32-len(netw_part))
    print('Scan completed. {} hosts up in {}/{}'.format(
        listener_thread.hostup_counter,
        sender_thread.bin_to_dotted_decimal(netw_addr), subnet ))

def calc_addr_range(cidr_type_addr):
    subnet = int(cidr_type_addr[-2:])

    # create string of binary address
    addr_blocks = [int(block) for block in cidr_type_addr[:-3].split('.')]
    bin_addr = "{0:08b}{1:08b}{2:08b}{3:08b}".format(*addr_blocks)

    netw_part = bin_addr[:subnet]

    # create list of all possible hostparts (stored as tuples, i.e. (0,0,0,1)
    return (netw_part, subnet, [tup for tup in product(range(2), repeat=32-subnet)])


def printHeaders(header_list):
    # prints out field info from given header
    cntr = 1
    for header in header_list:
        print('Header nr {}:'.format(cntr))
        cntr += 1
        for tup in header._fields_:
            if tup[0] == 'src':
                print('-{:15}{}'.format('src:', header.src_addr))
            elif tup[0] == 'dst':
                print('-{:15}{}'.format('dst:', header.dst_addr))
            else:
                print('-{:15}{}'.format(tup[0]+':', getattr(header, tup[0])))
        print()


if args.network_address:
    run = True
    try:
        # if this fails, exit
        test_socket = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_ICMP)
    except PermissionError:
        run = False
        print('root needed')
    except:
        run = False
        print('Cannot create socket')
    finally:
        try:
            test_socket.close()
        except:
            pass
    if run:
        main(args.network_address)
else:
    print('No address given.')
#%%
