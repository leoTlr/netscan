#!/usr/bin/python
#%%

import argparse
import threading
import socket # test for root
from itertools import product # calc_addr_range()
from re import fullmatch # address validation

from ressources.protocol_structs import IP, ICMP
from ressources.thread_classes import listenerThread, udpSenderThread

from traceback import format_exc # debug
import time # debug

parser = argparse.ArgumentParser()

parser.add_argument('ip_address', help='IPv4 Address in CIDR-notation')
parser.add_argument('-nm', '--netmask', help='netmask in dotted decimal notation \
                    (only needed if ip_address not in CIDR)')

args = parser.parse_args()


def main(cidr_type_address, dd_netmask=None):
    # separates address to network part and all possible hostparts in subnet
    if not dd_netmask:
        netw_part, subnet, hostparts_tuple_list = cidr_calc_addr_range(cidr_type_address)
    else:
        netw_part, subnet, hostparts_tuple_list = dd_netmask_calc_addr_range(addr, dd_netmask)

    # remove network and broadcast addresses
    # /31 produces an empty list, sice there are no host-addresses
    # /32 produces a list containing only the input address for single IP checks
    hostparts_tuple_list = hostparts_tuple_list[1:-1]

    # create listener thread
    listener_thread = listenerThread()
    listener_thread.start()

    # create sender thread
    sender_thread = udpSenderThread(netw_part, hostparts_tuple_list)
    sender_thread.start()

    # start sending as soon as listener thread is ready
    if listener_thread.is_listening:
        sender_thread.waitLock.release()

    # wait for sender thread to complete
    sender_thread.join()
    time.sleep(2) # wait for responses
    listener_thread.stop()
    listener_thread.join() # wait for listener to finish

    netw_addr = netw_part+'0'*(32-len(netw_part))
    print('Scan completed. {} hosts up in {}/{}'.format(
        listener_thread.hostup_counter,
        sender_thread.bin_to_dotted_decimal(netw_addr), subnet ))

def cidr_calc_addr_range(cidr_type_addr):
    subnet = int(cidr_type_addr[-2:])

    # create string of binary address
    addr_blocks = [int(block) for block in cidr_type_addr[:-3].split('.')]
    bin_addr = "{0:08b}{1:08b}{2:08b}{3:08b}".format(*addr_blocks)

    netw_part = bin_addr[:subnet]

    # create list of all possible hostparts (stored as tuples, i.e. (0,0,0,1)
    return (netw_part, subnet, [tup for tup in product(range(2), repeat=32-subnet)])


def printHeaders(header_list):
    # prints out field info from given header
    cntr = 1
    for header in header_list:
        print('Header nr {}:'.format(cntr))
        cntr += 1
        for tup in header._fields_:
            if tup[0] == 'src':
                print('-{:15}{}'.format('src:', header.src_addr))
            elif tup[0] == 'dst':
                print('-{:15}{}'.format('dst:', header.dst_addr))
            else:
                print('-{:15}{}'.format(tup[0]+':', getattr(header, tup[0])))
        print()

def is_valid_cidr(address):
    try:
        split = address.split('/')
        if len(split)==2:
            hostpart = split[0]
            split_hostpart = hostpart.split('.')
            subnet = int(split[1])
            if not 0<subnet<=32:
                return False
            elif not len(split_hostpart)==4:
                return False
            elif not all([0<=int(nr)<=255 for nr in split_hostpart]):
                return False
            else:
                return True
        else:
            return False
    except:
        return False

def is_valid_dd_netmask(address, netmask): # TODO
    try:
        addr_split = address.split('.')
        netm_split = netmask.split('.')
        if not len(addr.split)==4 or not len(netm_split)==4:
            return False
        elif not all([0<=int(nr)<=255 for nr in addr_split]):
            return False
        elif not all([0<=int(nr)<=255 for nr in netm_split]):
            return False
        else:
            return False
    except:
        return False


if args.ip_address:
    run = True
    try:
        # if this fails, exit
        test_socket = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_ICMP)
    except PermissionError:
        run = False
        print('root needed')
    except:
        run = False
        print('Cannot create socket')
    finally:
        try:
            test_socket.close()
        except:
            pass
    if run:
        if is_valid_cidr(args.ip_address):
            main(args.ip_address)
        elif is_valid_dd_netmask(args.ip_address, args.netmask):
            main(args.ip_address, args.netmask)
        else:
            print('input address not valid')
else:
    print('No address given.')
#%%
