#!/usr/bin/python

import argparse
import threading
import socket # test for root
from re import fullmatch # address validation
import time # wait for late responses
from datetime import datetime # timestamp for xml output
import xml.etree.ElementTree as ET # xml writing/parsing
from sys import exit

from ressources.thread_classes import listenerThread, udpSenderThread

from traceback import format_exc # debug

desc = """
Host discovery tool.
Will list and count all responding devices in given network by sending an
UDP-packet to a closed port at each address in network and waiting for
ICMP: Port unreachable responses.
"""

parser = argparse.ArgumentParser(description=desc)

parser.add_argument('ip_address', metavar='IPv4-address', help='IPv4 Address in CIDR-notation')
parser.add_argument('-nm', '--netmask', help='netmask in dotted decimal notation \
                    (only needed if ip_address not in CIDR-notation)', metavar='NM')
parser.add_argument('-w', '--wait', help='define time (seconds) to wait for responses \
                     after all packets are sent. Default 2', type=int, metavar='SEC')
parser.add_argument('-p', '--port', help='define a closed UDP port to use. Default 65333',
                    type=int)
parser.add_argument('-q', '--quiet', action='store_true',
                    help='only output number of discovered hosts (or number of changes since\
                     save if -c is selected)')
parser.add_argument('-s', '--save', action='store_true', help='save discovered hosts \
                        as .xml file in ./saved_scans')
parser.add_argument('-c', '--compare', metavar='PATH', help='scan and compare with \
                    saved hosts in file. If this is selected with -q, the number of\
                     changes is returned')
# TODO: -s and -c in mutually exclusive grp
#       input validation for -c
args = parser.parse_args()


def main(address, dd_netmask=None):
    # calculate first and last address of given IPv4-network
    if not dd_netmask: # cidr-notation
        network_addr, broadcast_addr, subnet = calc_addr_range(address)
    else: # non-cidr-notation
        network_addr, broadcast_addr, subnet = calc_addr_range(address, dd_netmask)

    scan_ok = True # gets false if sth goes wrong

    # create listener thread
    listener_thread = listenerThread()
    if args.quiet:
        listener_thread.quiet = True
    if args.save or args.compare:
        listener_thread.prepare_xml_data = True

    listener_thread.start()

    # create sender thread
    sender_thread = udpSenderThread(network_addr, broadcast_addr)
    if args.port:
        sender_thread.closed_port = args.port
    if args.quiet:
        sender_thread.quiet = True

    sender_thread.start()

    # start sending as soon as listener thread is ready
    while not listener_thread.is_listening:
        if listener_thread.stopped():
            scan_ok = False
            break
        else:
            time.sleep(0.005)
    sender_thread.start_event.set()

    if sender_thread.stopped():
        scan_ok = False

    sender_thread.join(timeout=5) # wait for sender thread to complete

    # wait for late responses
    if args.wait:
        time.sleep(args.wait)
    else:
        time.sleep(2)

    listener_thread.stop()
    listener_thread.join(timeout=5) # wait for listener to finish

    netw_addr_str = sender_thread.bin2DottedDecimal(network_addr)
    cidr_nw_str = '{}/{}'.format(netw_addr_str, subnet)

    if args.save or args.compare:
        data_set = listener_thread.xml_set

    if args.save:
        save_xml(data_set, cidr_nw_str)

    if scan_ok:
        if args.compare:
            if not args.quiet:
                compare_xml(data_set, cidr_nw_str, args.compare)
            else:
                print(compare_xml(data_set, cidr_nw_str, args.compare))
            exit(0)
        else:
            if not args.quiet:
                print('{} hosts up in {}'.format(listener_thread.hostup_counter, cidr_nw_str))
            else:
                print(listener_thread.hostup_counter)
            exit(0)
    else:
        if not args.quiet:
            print('[ERROR] scan failed')
        exit(-1)

def save_xml(data_set, network):
    # TODO:  - with import pathlib, check if folder exists, else create
    #        - allow custom paths
    #        - save as normal user, not root

    timestamp = '{:%Y-%m-%d-%H:%M:%S}'.format(datetime.now())
    attributes = {}
    attributes['network'] = network
    attributes['timestamp'] = timestamp

    scan = ET.Element('scan', attrib=attributes)

    for ip_str, mac_str in data_set:
        host = ET.SubElement(scan, 'host')
        ET.SubElement(host, 'ip').text = ip_str
        ET.SubElement(host, 'mac').text = mac_str

    tree = ET.ElementTree(scan)

    filename = './saved_scans/scan_{}.xml'.format(timestamp)

    with open(filename, 'wb') as xml_file:
        tree.write(xml_file)

    if not args.quiet:
        print('saved hosts to "{}"'.format(filename))

def compare_xml(data_set, network, path):
    # compare discovered hosts with a .xml save of previous search

    # TODO: - path checking
    #       - file syntax checking

    saved_set = set()
    changes_less = 0
    changes_more = 0

    with open(path, 'r') as xml_file:
        tree = ET.parse(xml_file)
        scan = tree.getroot()

        if not args.quiet:
            print('Comparison with saved scan:')
        if network != scan.get('network'):
            if not args.quiet:
                print('[WARNING] comparing scans from different networks')

        for host in scan:
            for ip, mac in ((a,b) for a in host.iter('ip') for b in host.iter('mac')):
                h_tup = (ip.text, mac.text)
                if h_tup not in data_set:
                    if not args.quiet:
                        print('[-] {:<16}  {}'.format(h_tup[0], h_tup[1]))
                    changes_less += 1
                saved_set.add(h_tup)

        for ip, mac in data_set:
            if (ip, mac) not in saved_set:
                print('[+] {:<16}  {}'.format(ip, mac))
                changes_more += 1

        changes_combined = changes_less+changes_more
        if not args.quiet:
            print('no longer online: {}'.format(changes_less))
            print('additional hosts: {}'.format(changes_more))
            print('combined changes: {}'.format(changes_combined))

        return changes_combined

def calc_addr_range(address, dd_netmask=None):
    # calculate network address and broadcast Address
    # out of given ip address string
    # input either CIDR-type address or dotted decimal and separate netmask

    # separate decimal str blocks into 4 ints
    if not dd_netmask:
        # if CIDR-type, also get subnet (i.e '24' for '.../24')
        dd_addr, subnet_str = address.split('/')
        addr_blocks = [int(block) for block in dd_addr.split('.')]
    else:
        addr_blocks = [int(block) for block in address.split('.')]

    # concatenate decimal blocks to address
    bin_addr = 0b0
    addr_blocks = zip((24, 16, 8, 0), addr_blocks)
    for lshift_val, block in addr_blocks:
        bin_addr += (block << lshift_val)

    if not dd_netmask:
        subnet = int(subnet_str)

        # eqal to ('1'*subnet)+('0'*(32-subnet)) as int
        # i.e 0b11111111111111111111111100000000 for /24
        bin_netm = (2**(32-(32-subnet))-1) << (32-subnet)

    else:
        netm_blocks = [int(block) for block in dd_netmask.split('.')]

        # concatenate decimal blocks to address
        bin_netm = 0b0
        netm_blocks = zip((24, 16, 8, 0), netm_blocks)
        for lshift_val, block in netm_blocks:
            bin_netm += (block << lshift_val)

        # i.e for /24: subnet=24
        subnet = 32-((((2**32)-1)-bin_netm).bit_length())

    network_addr = bin_addr&bin_netm
    broadcast_addr = network_addr+(2**(32-subnet)-1)

    return (network_addr, broadcast_addr, subnet)

def is_valid_cidr(address):
    # for tye: 192.168.2.0/24
    try:
        split = address.split('/')
        if len(split)==2:
            hostpart = split[0]
            split_hostpart = hostpart.split('.')
            subnet = int(split[1])
            if not 0<subnet<=32:
                return False
            elif not len(split_hostpart)==4:
                return False
            elif not all([0<=int(nr)<=255 for nr in split_hostpart]):
                return False
            else:
                return True
        else:
            return False
    except:
        return False

def is_valid_dd_netmask(address, netmask):
    # for type 192.168.2.0 255.255.255.0
    try:
        addr_split = address.split('.')
        netm_split = netmask.split('.')
        bin_netm = '{0:08b}{1:08b}{2:08b}{3:08b}'.format(*[int(block) for block in netm_split])
        if not len(addr_split)==4:
            return False
        elif not all([0<=int(nr)<=255 for nr in addr_split]):
            return False
        elif not all([0<=int(nr)<=255 for nr in netm_split]):
            return False
        elif not fullmatch('^(1{0,31}0{0,31})$', bin_netm):
            # attention: pattern only checks for bin_netm being ones followed by zeroes
            # BUT also matches len(bin_netm) != 32
            # -> need to explicitly check len
            return False
        elif not len(bin_netm)==32:
            return False
        else:
            return True
    except:
        return False

if args.ip_address:
    if args.port and not (1 <= args.port <= 65535):
        if not args.quiet:
            print('[ERROR] invalid port. exiting')
        exit(-1)
    try: # raw socket of AF_PACKET needed for listener-thread
        with socket.socket(socket.AF_PACKET, socket.SOCK_RAW, socket.ntohs(0x0003)) as s:
            s.close()
    except PermissionError:
        if not args.quiet:
            print('[ERROR] root needed')
        exit(-1)
    except:
        if not args.quiet:
            print('[ERROR] could not create socket. exiting')
        exit(-1)

    if is_valid_cidr(args.ip_address):
        main(args.ip_address)
    elif is_valid_dd_netmask(args.ip_address, args.netmask):
        main(args.ip_address, args.netmask)
    else:
        if not args.quiet:
            print('[ERROR] input address and/or netmask not valid. exiting')
        exit(-1)
else:
    if not args.quiet:
        print('[ERROR] No address given.')
    exit(-1)
