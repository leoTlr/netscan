#!/usr/bin/python

import argparse
import threading
import socket # test for root
from itertools import product # calc_addr_range()
from re import fullmatch # address validation
import time # wait for late responses

from ressources.thread_classes import listenerThread, udpSenderThread

from traceback import format_exc # debug


parser = argparse.ArgumentParser()

parser.add_argument('ip_address', help='IPv4 Address in CIDR-notation')
parser.add_argument('-nm', '--netmask', help='netmask in dotted decimal notation \
                    (only needed if ip_address not in CIDR)')
parser.add_argument('-w', '--wait', help='define time (seconds) to wait for responses \
                     after all packets are sent. Default 2', type=int)
parser.add_argument('-p', '--port', help='define a closed UDP port to use. Default 65333',
                    type=int)

args = parser.parse_args()


def main(address, dd_netmask=None):
    # separates address to network part and all possible hostparts in subnet
    if not dd_netmask: # cidr-notation
        netw_part, subnet, hostparts_tuple_gen = calc_addr_range(address)
    else: # non-cidr-notation
        netw_part, subnet, hostparts_tuple_gen = calc_addr_range(address, dd_netmask)

    # remove first address (network address)
    hostparts_tuple_gen.__next__()
    # note: if /32, this produces ()
    # single target schans still possible (see: udpSenderThread.yield_next_addr_bin())

    try:
        # create listener thread
        listener_thread = listenerThread()
        listener_thread.start()

        # create sender thread
        sender_thread = udpSenderThread(netw_part, hostparts_tuple_gen, args.port)
        sender_thread.start()

        # start sending as soon as listener thread is ready
        while not listener_thread.is_listening:
            time.sleep(0.005)
        sender_thread.start_event.set()

        sender_thread.join(timeout=5) # wait for sender thread to complete

        # wait for late responses
        if args.wait:
            time.sleep(args.wait)
        else:
            time.sleep(2)

        listener_thread.stop()
        listener_thread.join(timeout=5) # wait for listener to finish

    except KeyboardInterrupt:
        print('\nInterrupted by user')

    finally:
        try:
            listener_thread.stop()
            sender_thread.stop()
        except:
            pass

        netw_addr = netw_part+'0'*(32-len(netw_part))
        print('Scan completed. {} hosts up in {}/{}'.format(
        listener_thread.hostup_counter,
        sender_thread.bin_to_dotted_decimal(netw_addr),
        subnet ))

def calc_addr_range(address, netmask=None):
    # takes either cidr-type address OR dotted decimal address + dotted decimal netmask
    # Important: validation needs to be done before

    # create string of binary address
    if not netmask:
        dd_addr, subnet_str = address.split('/')
        addr_blocks = [int(block) for block in dd_addr.split('.')]
    else:
        addr_blocks = [int(block) for block in address.split('.')]

    bin_addr = '{0:08b}{1:08b}{2:08b}{3:08b}'.format(*addr_blocks)

    if not netmask:
        subnet = int(subnet_str) # just take subnet nr after /
    else:
        # create string of binary netmask and cout ones
        netm_blocks = [int(block) for block in netmask.split('.')]
        bin_netm = '{0:08b}{1:08b}{2:08b}{3:08b}'.format(*netm_blocks)
        subnet = bin_netm.count('1')

    bin_netw_part = bin_addr[:subnet]
    broadcast_tup = (1)*subnet # for not incuding the broadcast address in the generator

    # create list of all possible hostparts (stored as tuples, i.e. (0,0,0,1)
    return (bin_netw_part, subnet, (tup for tup in product(range(2), repeat=32-subnet) if tup!=broadcast_tup))

def is_valid_cidr(address):
    try:
        split = address.split('/')
        if len(split)==2:
            hostpart = split[0]
            split_hostpart = hostpart.split('.')
            subnet = int(split[1])
            if not 0<subnet<=32:
                return False
            elif not len(split_hostpart)==4:
                return False
            elif not all([0<=int(nr)<=255 for nr in split_hostpart]):
                return False
            else:
                return True
        else:
            return False
    except:
        return False

def is_valid_dd_netmask(address, netmask):
    try:
        addr_split = address.split('.')
        netm_split = netmask.split('.')
        bin_netm = '{0:08b}{1:08b}{2:08b}{3:08b}'.format(*[int(block) for block in netm_split])
        if not len(addr_split)==4:
            return False
        elif not all([0<=int(nr)<=255 for nr in addr_split]):
            return False
        elif not all([0<=int(nr)<=255 for nr in netm_split]):
            return False
        elif not fullmatch('^(1{0,31}0{0,31})$', bin_netm):
            # attention: pattern only checks for bin_netm being ones followed by zeroes
            # BUT also matches len(bin_netm) != 32
            # -> need to explicitly check len
            print('fullmatch failed', bin_netm)
            return False
        elif not len(bin_netm)==32:
            return False
        else:
            return True
    except:
        return False


if args.ip_address:
    run = True
    if args.port and not 1 <= args.port <= 65535:
        print('invalid port')
        run = False
    try:
        # if this fails, dont run main
        test_socket = socket.socket(socket.AF_PACKET, socket.SOCK_RAW, socket.ntohs(0x0003))
    except PermissionError:
        run = False
        print('root needed')
    except:
        run = False
        print('Cannot create socket.')
    finally:
        try:
            test_socket.close()
        except:
            pass
    if run:
        if is_valid_cidr(args.ip_address):
            main(args.ip_address)
        elif is_valid_dd_netmask(args.ip_address, args.netmask):
            main(args.ip_address, args.netmask)
        else:
            print('input address not valid')
else:
    print('No address given.')
